import cv2
import numpy as np
import heapq


class LiveWireSegmentation:
    def __init__(self, image_path):
        self.image = cv2.imread(image_path)
        self.gray_image = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
        self.smoothed_image = cv2.GaussianBlur(self.gray_image, (5, 5), 0)  # Apply Gaussian smoothing
        self.gradient_x = cv2.Sobel(self.smoothed_image, cv2.CV_64F, 1, 0, ksize=3)
        self.gradient_y = cv2.Sobel(self.smoothed_image, cv2.CV_64F, 0, 1, ksize=3)
        self.result_image = self.image.copy()
        self.mask = np.zeros_like(self.gray_image, dtype=np.uint8)
        self.points = []

        cv2.namedWindow("Live Wire Segmentation")
        cv2.setMouseCallback("Live Wire Segmentation", self.mouse_callback)

        # Display the initial image
        self.draw_path()

    def mouse_callback(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            self.points = [(x, y)]
            print("Mouse clicked")
            self.grow_path()

    def grow_path(self):
        while True:
            print("Path growing")
            if not self.points:
                break

            current_point = self.points[-1]

            neighbors = self.get_neighbors(current_point)

            if not neighbors:
                print("No nieghbours")
                break

            next_point = min(neighbors, key=lambda neighbor: self.cost(current_point, neighbor))

            if next_point in self.points:
                print("Hitting tail")
                break

            self.points.append(next_point)

            # Update the image after every 10 points
            if len(self.points) % 10 == 0:
                print("Draw")
                self.draw_path()
                cv2.waitKey(1000)  # Allow time for the window to update
                print("After wait")


    def draw_path(self):
        self.result_image = self.image.copy()  # Reset result image
        self.mask = np.zeros_like(self.gray_image, dtype=np.uint8)

        if len(self.points) > 1:
            path = np.array(self.points)

            # Close the path
            path = np.concatenate((path, path[0:1]))

            cv2.polylines(self.mask, [path], isClosed=True, color=255, thickness=2)

        # Draw points on the result image
        for i, point in enumerate(self.points):
            if i == 0:
                cv2.circle(self.result_image, point, 10, (0, 0, 255), -1)  # Mark the starting point with a red big dot
            else:
                cv2.circle(self.result_image, point, 5, (0, 255, 0), -1)

        cv2.imshow("Live Wire Segmentation", cv2.addWeighted(self.image, 0.7, cv2.cvtColor(self.mask, cv2.COLOR_GRAY2BGR), 0.3, 0))

    def cost(self, p1, p2):
        intensity_difference = abs(int(self.gray_image[p1[1], p1[0]]) - int(self.gray_image[p2[1], p2[0]]))
        return intensity_difference


    def get_neighbors(self, point, step_size_factor=0.1, exclude_last_n=10):
        neighbors = []

        gradient_magnitude = np.sqrt(self.gradient_x[point[1], point[0]]**2 + self.gradient_y[point[1], point[0]]**2)

        if gradient_magnitude == 0:
            gradient_magnitude = 1  # Avoid division by zero

        for i in range(-3, 4):
            for j in range(-3, 4):
                x, y = point[0] + int(i), point[1] + int(j)
                if 0 <= x < self.gray_image.shape[1] and 0 <= y < self.gray_image.shape[0]:
                    candidate_point = (x, y)
                    if candidate_point not in self.points[-exclude_last_n:]:
                        neighbors.append(candidate_point)

        return neighbors


if __name__ == "__main__":
    image_path = "experimental/Test_live_wire.JPG"  # Replace with the path to your image
    live_wire_segmentation = LiveWireSegmentation(image_path)

    while True:
        key = cv2.waitKey(1) & 0xFF
        if key == 27:  # Press 'Esc' to exit
            break

    cv2.destroyAllWindows()
