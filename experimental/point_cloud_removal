import matplotlib.pyplot as plt
import numpy as np

def parse_lumen_point_cloud(file_path):
    # Initialize lists to store the parsed values
    data = []
    # Open the text file for reading
    with open(file_path, 'r') as file:
        for line in file:
            # Split the line into three values
            parts = line.strip().split()

            # Ensure there are three values on each line
            if len(parts) == 3:
                # Parse the values as floats and append them to the respective lists
                px, py, pz = float(parts[0]), float(parts[1]), float(parts[2])
                data.append((px, py, pz))
            else:
                print(f"Skipping invalid line: {line.strip()}")

    return np.array(data)

def parse_point_cloud_CT_lumen(file_path):
    # Initialize lists to store the parsed values
    data = []
    # Open the text file for reading
    with open(file_path, 'r') as file:
        for line in file:
            # Split the line into three values
            parts = line.strip().split()

            # Ensure there are three values on each line
            if len(parts) == 3:
                # Parse the values as floats and append them to the respective lists
                px, py, pz = float(parts[0]), float(parts[1]), float(parts[2])
                data.append((px, py, pz))
            else:
                print(f"Skipping invalid line: {line.strip()}")
    # Convert each inner list to strings with spaces between elements
    formatted_data = [' '.join(map(str, inner)) for inner in data]

    # Convert the formatted strings back to a list of lists
    result = [list(map(float, inner.split())) for inner in formatted_data]
    return np.array(result)


# Sample point clouds (replace with your own data)
file_path_2 = "ArCoMo6_lumen_pp.txt"  # Replace with the path to your text file
file_path_3 = "saved_registered_splines.txt"
point_cloud_CT = parse_point_cloud_CT_lumen(file_path_2)
point_cloud_OCT = parse_lumen_point_cloud(file_path_3)
# Assuming point_cloud_CT and point_cloud_OCT are lists of (x, y, z) points

import matplotlib.pyplot as plt

# Assuming point_cloud_CT and point_cloud_OCT are lists of (x, y, z) points
# Create a function to check if a point is inside a polygon

def point_in_polygon(point, polygon):
    x, y, z = point
    n = len(polygon)
    inside = False

    for i in range(n):
        xi, yi, zi = polygon[i]
        xj, yj, zj = polygon[(i + 1) % n]

        # Check if the point is between the vertices in the y-coordinate
        if (yi < y < yj) or (yj < y < yi):
            # Calculate the x-coordinate where the line crosses the horizontal line at y
            x_cross = (xj - xi) * (y - yi) / (yj - yi) + xi

            # Check if the x-coordinate of the point is to the left of the line
            if x < x_cross:
                inside = not inside

    return inside

# Initialize a list to store the points within point_cloud_CT that are inside point_cloud_OCT
points_inside_OCT = []

# Iterate through each point in point_cloud_CT and check if it's inside point_cloud_OCT
for point_CT in point_cloud_CT:
    if point_in_polygon(point_CT, point_cloud_OCT):
        points_inside_OCT.append(point_CT)
        print("loop")

# Separate x, y, and z coordinates for plotting
x_CT, y_CT, z_CT = zip(*points_inside_OCT)
x_OCT, y_OCT, z_OCT = zip(*point_cloud_OCT)

# Create a scatter plot of the updated point_cloud_CT in blue and point_cloud_OCT in red
plt.scatter(x_CT, y_CT, c='blue', label='Updated point_cloud_CT')
plt.scatter(x_OCT, y_OCT, c='red', label='point_cloud_OCT')

plt.xlabel('X')
plt.ylabel('Y')
plt.legend()
plt.title('Updated point_cloud_CT and point_cloud_OCT')

plt.show()
